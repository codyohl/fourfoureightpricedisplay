// Pin numbers (These numbers are on the Audrino board)
#define CLOCK_1 7
#define CLOCK_2 12
#define DATA_1 8
#define DATA_2 13

void setup() {
  pinMode(CLOCK_1, OUTPUT);
  pinMode(CLOCK_2, OUTPUT);
  pinMode(DATA_1, OUTPUT);
  pinMode(DATA_2, OUTPUT);
  Serial.begin(9600);
}

int current_row = 1;
int current_numberToDisplay = 0;

void showNumber(int row, int numberToDisplay)
{
  // The LED driver chip has a 36 bit cycle
  int cycle[36];

  // These arrays are generated by the code generator
  int segments[] = { 10,17,20,26,32,37,43,50,55,63,0,1,2,3,5,6,-1,3,5,-1,2,3,4,0,6,-1,2,3,4,5,6,-1,1,4,3,5,-1,2,1,4,5,6,-1,2,1,0,6,5,4,-1,1,2,3,5,-1,1,2,3,4,0,6,5,-1,1,2,3,4,5,6,-1 };
  int pins[] = { 2,3,4,5,6,7,8,13,14,15,20,21,22,23,24,25,27,30,31,32,33 };

  // First, select the row.
  // Note that the row number is one based, and the loop is going backwards
  for (int k = 6; k > 0; k--)
  {
    digitalWrite(CLOCK_2, LOW);
    digitalWrite(DATA_2, k == row ? HIGH : LOW);
    delay(1);
    digitalWrite(CLOCK_2, HIGH);
  }
  // Initialize the cycle with the first bit 1 and all other zeros
  for (int i = 0; i < 36; i++)
  {
    cycle[i] = (i == 0) ? 1 : 0;
  }

  // 1000 is used to signal switching off
  if (numberToDisplay != 1000)
  {
    // For each digit
    int remainder = numberToDisplay;
    for (int digitIndex = 2; digitIndex >= 0; digitIndex--)
    {
      // Extract the least significant digit
      int digit = remainder % 10;
      
      // Shift away it
      remainder -= digit;
      remainder /= 10;
      
      // Get the starting index to the segment list
      int index = segments[digit];

      // For each segments in the digit
      while (segments[index] != -1)
      {
        // Read the segment number from the array
        int segmentNumber = segments[index];
        
        // Compute the pin index (which is the index to the pin array)
        int pinIndex = digitIndex * 7 + segmentNumber;
        
        // Compute the pin number
        int pinNumber = pins[pinIndex];
        
        // Turn it on
        cycle[pinNumber] = 1;
        index++;
      }
    }
  }
  
  // Shift all the 36 bits into the LED display driver
  for (int i = 0; i < 36; i++)
  {
    digitalWrite(CLOCK_1, LOW);
    delay(1);
    digitalWrite(DATA_1, cycle[i] == 0 ? LOW : HIGH);
    delay(1);
    digitalWrite(CLOCK_1, HIGH);
  } 
}

// This is a simple odometer that loop through all the numbers
// We can do something more interesting if wished
void loop()
{
  byte b;
  while(Serial.available() <= 0) { }
  if (b = Serial.read() != 255)
    return;

  while (Serial.available() < 3) { }
  //byte contents[3] = { Serial.read(), Serial.read(), Serial.read() };

  byte row  = Serial.read();
  unsigned int val = Serial.read();
  val = val << 8;
  val += Serial.read();
  
//  Serial.print(row);
//  Serial.print(",");
//  Serial.println(val);
  showNumber(row, val);
}

void loop_all_numbers()
{
  showNumber(current_row, current_numberToDisplay);
  current_numberToDisplay += 1;
  if (current_numberToDisplay > 1000)
  {
    current_numberToDisplay = 0;
    current_row++;
    if (current_row == 7) // current
    {
      current_row = 1;
    }
  }
}
